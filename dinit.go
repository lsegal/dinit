// Package dinit performs Dependency Injection (DI) for initializer functions.
package dinit

// Init takes a set of values and provider functions and initializes all
// functions in order, injecting all values generated by provider functions
// into the initializer functions of any dependent provider functions.
//
// The list of vals can be a set of concrete struct types (or pointers to
// structs), or functions. If a function is passed, this function will send in a
// matching set of input arguments that were passed in from other concrete
// structs or created by provider functions. Function arguments can also only
// contain interfaces, structs, or pointers to structs. In the case of interface
// arguments, this function will use the first matching concrete type as input
// to this argument.
//
// If a function argument contains an error type in its return values
// and returns an error during execution, Init() will stop initialization and
// return that error as the result of this call.
//
// Integers, strings, and non-struct types are unsupported as arguments for any
// functions or values. This is because these types are inherently ambiguous
// when matching against function input arguments. Given two functions that
// produce integer values and one that takes an integer input, it would not be
// clear which one to use.
//
// Function types as input arguments are not illegal but not yet supported.
//
// Return types for provider functions must be unique. In other words, you can
// only provide a value for type X once as either a concrete value or provided
// by a single initialization function.
//
// Provider functions may not be interdependent. If provider function A relies
// on input from provider function B and B relies on A, this function will
// return a cycle error.
//
// This function does not support any mechanism to run a callback at the end of
// initialization. If you need to perform some task on the generated objects,
// add a custom provider function that contains all necessary dependent values
// as function arguments. See the finalizer() function in the example to see
// how this can be achieved.
func Init(vals ...interface{}) error {
	r := &resolver{}
	if err := r.init(vals); err != nil {
		return err
	}
	r.resolve()
	for _, fn := range r.fns {
		if err := r.validate(fn, nil); err != nil {
			return err
		}
	}
	return r.invoke()
}
